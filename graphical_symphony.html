<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Symphony: A Multidimensional Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #ffeaa7 75%, #a8edea 100%);
            background-size: 400% 400%;
            animation: gradientShift 20s ease infinite;
            overflow-x: hidden;
            color: #2d3748;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            padding: 30px 0;
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 3.5em;
            font-weight: 200;
            letter-spacing: -2px;
            background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(102, 126, 234, 0.3);
        }

        .subtitle {
            color: rgba(45, 55, 72, 0.8);
            font-size: 1.2em;
            font-weight: 300;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 600px;
            margin-bottom: 30px;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #neuralCanvas {
            z-index: 2;
        }

        #particleCanvas {
            z-index: 1;
            opacity: 0.6;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .control-title {
            font-size: 1.3em;
            color: #667eea;
            margin-bottom: 15px;
            font-weight: 300;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #4a5568;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(90deg, #a8edea 0%, #fed6e3 100%);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
        }

        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            margin: 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 10px;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: 200;
            background: linear-gradient(90deg, #667eea, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 0.9em;
            color: #4a5568;
            margin-top: 5px;
        }

        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .viz-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .chart-canvas {
            width: 100%;
            height: 250px;
            border-radius: 10px;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            margin-top: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            margin-top: 20px;
        }

        .info-section h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-weight: 400;
        }

        .info-section p {
            color: #4a5568;
            line-height: 1.6;
        }

        .equation {
            font-family: 'Courier New', monospace;
            background: linear-gradient(90deg, rgba(168, 237, 234, 0.2), rgba(254, 214, 227, 0.2));
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            overflow-x: auto;
        }

        @media (max-width: 768px) {
            h1 { font-size: 2em; }
            .canvas-container { height: 400px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Neural Symphony</h1>
            <p class="subtitle">A Convergence of Intelligence, Physics, and Harmony</p>
        </div>

        <div class="canvas-container">
            <canvas id="particleCanvas"></canvas>
            <canvas id="neuralCanvas"></canvas>
        </div>

        <div class="controls">
            <div class="control-panel">
                <h2 class="control-title">Neural Network Controls</h2>
                <div class="control-group">
                    <label>Learning Rate: <span id="learningRateValue">0.01</span></label>
                    <input type="range" id="learningRate" min="0.001" max="0.1" step="0.001" value="0.01">
                </div>
                <div class="control-group">
                    <label>Network Complexity: <span id="complexityValue">3</span></label>
                    <input type="range" id="complexity" min="2" max="5" step="1" value="3">
                </div>
                <button id="trainBtn">Train Network</button>
                <button id="resetBtn">Reset Network</button>
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value" id="accuracy">0%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="epochs">0</div>
                        <div class="stat-label">Epochs</div>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <h2 class="control-title">Particle Physics</h2>
                <div class="control-group">
                    <label>Particle Count: <span id="particleCountValue">500</span></label>
                    <input type="range" id="particleCount" min="100" max="2000" step="100" value="500">
                </div>
                <div class="control-group">
                    <label>Gravity: <span id="gravityValue">0.5</span></label>
                    <input type="range" id="gravity" min="0" max="2" step="0.1" value="0.5">
                </div>
                <div class="control-group">
                    <label>Turbulence: <span id="turbulenceValue">0.3</span></label>
                    <input type="range" id="turbulence" min="0" max="1" step="0.1" value="0.3">
                </div>
                <button id="particleBtn">Restart Simulation</button>
                <button id="attractorBtn">Add Attractor</button>
            </div>

            <div class="control-panel">
                <h2 class="control-title">Audio Synthesis</h2>
                <div class="control-group">
                    <label>Base Frequency: <span id="frequencyValue">440</span> Hz</label>
                    <input type="range" id="frequency" min="220" max="880" step="10" value="440">
                </div>
                <div class="control-group">
                    <label>Harmonics: <span id="harmonicsValue">3</span></label>
                    <input type="range" id="harmonics" min="1" max="7" step="1" value="3">
                </div>
                <button id="playBtn">Play Neural Music</button>
                <button id="stopBtn">Stop</button>
                <button id="generateBtn">Generate Melody</button>
            </div>
        </div>

        <div class="visualization-grid">
            <div class="viz-card">
                <h3 class="control-title">Loss Function Landscape</h3>
                <canvas id="lossChart" class="chart-canvas"></canvas>
            </div>
            <div class="viz-card">
                <h3 class="control-title">Activation Patterns</h3>
                <canvas id="activationChart" class="chart-canvas"></canvas>
            </div>
            <div class="viz-card">
                <h3 class="control-title">Frequency Spectrum</h3>
                <canvas id="spectrumChart" class="chart-canvas"></canvas>
            </div>
            <div class="viz-card">
                <h3 class="control-title">Phase Space</h3>
                <canvas id="phaseChart" class="chart-canvas"></canvas>
            </div>
        </div>

        <div class="info-panel">
            <h2 class="control-title">Technical Architecture</h2>
            <div class="info-grid">
                <div class="info-section">
                    <h3>Neural Network</h3>
                    <p>Real-time backpropagation with adaptive learning rates using gradient descent optimization.</p>
                    <div class="equation">∇L = ∂L/∂w · σ'(z) · x</div>
                </div>
                <div class="info-section">
                    <h3>Particle System</h3>
                    <p>N-body simulation with gravitational forces and stochastic turbulence modeling.</p>
                    <div class="equation">F = G·m₁·m₂/r² + ξ(t)</div>
                </div>
                <div class="info-section">
                    <h3>Audio Generation</h3>
                    <p>Fourier synthesis with harmonic overtones mapped to network activation patterns.</p>
                    <div class="equation">y(t) = Σ Aₙ·sin(2πfₙt + φₙ)</div>
                </div>
                <div class="info-section">
                    <h3>Chaos Dynamics</h3>
                    <p>Lorenz attractor implementation with real-time phase space visualization.</p>
                    <div class="equation">dx/dt = σ(y-x)</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Neural Network Visualization
        class NeuralNetwork {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.layers = [4, 6, 6, 3];
                this.neurons = [];
                this.connections = [];
                this.weights = [];
                this.activations = [];
                this.learningRate = 0.01;
                this.epochs = 0;
                this.accuracy = 0;
                this.training = false;
                
                this.initializeNetwork();
            }

            initializeNetwork() {
                this.neurons = [];
                this.connections = [];
                this.weights = [];
                
                // Create neurons
                for (let l = 0; l < this.layers.length; l++) {
                    const layer = [];
                    const layerWidth = this.canvas.width / (this.layers.length + 1);
                    const x = layerWidth * (l + 1);
                    
                    for (let n = 0; n < this.layers[l]; n++) {
                        const y = (this.canvas.height / (this.layers[l] + 1)) * (n + 1);
                        layer.push({
                            x: x,
                            y: y,
                            activation: Math.random(),
                            bias: (Math.random() - 0.5) * 2,
                            velocity: { x: 0, y: 0 }
                        });
                    }
                    this.neurons.push(layer);
                }
                
                // Create connections with random weights
                for (let l = 0; l < this.layers.length - 1; l++) {
                    const layerWeights = [];
                    for (let i = 0; i < this.neurons[l].length; i++) {
                        const neuronWeights = [];
                        for (let j = 0; j < this.neurons[l + 1].length; j++) {
                            neuronWeights.push((Math.random() - 0.5) * 2);
                        }
                        layerWeights.push(neuronWeights);
                    }
                    this.weights.push(layerWeights);
                }
            }

            sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }

            sigmoidDerivative(x) {
                return x * (1 - x);
            }

            forward(input) {
                // Set input layer
                for (let i = 0; i < Math.min(input.length, this.neurons[0].length); i++) {
                    this.neurons[0][i].activation = input[i];
                }
                
                // Forward propagation
                for (let l = 1; l < this.layers.length; l++) {
                    for (let j = 0; j < this.neurons[l].length; j++) {
                        let sum = this.neurons[l][j].bias;
                        for (let i = 0; i < this.neurons[l - 1].length; i++) {
                            sum += this.neurons[l - 1][i].activation * this.weights[l - 1][i][j];
                        }
                        this.neurons[l][j].activation = this.sigmoid(sum);
                    }
                }
                
                // Return output
                return this.neurons[this.neurons.length - 1].map(n => n.activation);
            }

            train() {
                if (!this.training) return;
                
                // Generate training data (XOR-like pattern)
                const trainingData = [
                    { input: [0, 0, 0, 1], output: [1, 0, 0] },
                    { input: [0, 1, 0, 1], output: [0, 1, 0] },
                    { input: [1, 0, 1, 0], output: [0, 0, 1] },
                    { input: [1, 1, 0, 0], output: [1, 1, 0] }
                ];
                
                let totalError = 0;
                
                for (let data of trainingData) {
                    const output = this.forward(data.input);
                    
                    // Backpropagation
                    const errors = [];
                    
                    // Output layer error
                    const outputErrors = [];
                    for (let i = 0; i < output.length; i++) {
                        const error = data.output[i] - output[i];
                        outputErrors.push(error);
                        totalError += Math.abs(error);
                    }
                    errors.unshift(outputErrors);
                    
                    // Hidden layers error
                    for (let l = this.layers.length - 2; l > 0; l--) {
                        const layerErrors = [];
                        for (let i = 0; i < this.neurons[l].length; i++) {
                            let error = 0;
                            for (let j = 0; j < this.neurons[l + 1].length; j++) {
                                error += errors[0][j] * this.weights[l][i][j];
                            }
                            layerErrors.push(error);
                        }
                        errors.unshift(layerErrors);
                    }
                    
                    // Update weights
                    for (let l = 0; l < this.weights.length; l++) {
                        for (let i = 0; i < this.weights[l].length; i++) {
                            for (let j = 0; j < this.weights[l][i].length; j++) {
                                const delta = this.learningRate * errors[l][j] * 
                                            this.sigmoidDerivative(this.neurons[l + 1][j].activation) * 
                                            this.neurons[l][i].activation;
                                this.weights[l][i][j] += delta;
                            }
                        }
                    }
                    
                    // Update biases
                    for (let l = 1; l < this.neurons.length; l++) {
                        for (let i = 0; i < this.neurons[l].length; i++) {
                            this.neurons[l][i].bias += this.learningRate * errors[l - 1][i] * 
                                                       this.sigmoidDerivative(this.neurons[l][i].activation);
                        }
                    }
                }
                
                this.epochs++;
                this.accuracy = Math.max(0, 100 - totalError * 25);
                
                // Update display
                document.getElementById('accuracy').textContent = this.accuracy.toFixed(1) + '%';
                document.getElementById('epochs').textContent = this.epochs;
                
                if (this.training) {
                    requestAnimationFrame(() => this.train());
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw connections
                for (let l = 0; l < this.weights.length; l++) {
                    for (let i = 0; i < this.neurons[l].length; i++) {
                        for (let j = 0; j < this.neurons[l + 1].length; j++) {
                            const weight = this.weights[l][i][j];
                            const opacity = Math.abs(weight) / 2;
                            const hue = weight > 0 ? 250 : 330; // Purple for positive, pink for negative
                            
                            this.ctx.strokeStyle = `hsla(${hue}, 70%, 60%, ${opacity})`;
                            this.ctx.lineWidth = Math.abs(weight) * 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(this.neurons[l][i].x, this.neurons[l][i].y);
                            this.ctx.lineTo(this.neurons[l + 1][j].x, this.neurons[l + 1][j].y);
                            this.ctx.stroke();
                        }
                    }
                }
                
                // Draw neurons
                for (let layer of this.neurons) {
                    for (let neuron of layer) {
                        const activation = neuron.activation;
                        const radius = 15 + activation * 10;
                        
                        // Glow effect
                        const gradient = this.ctx.createRadialGradient(
                            neuron.x, neuron.y, 0,
                            neuron.x, neuron.y, radius * 2
                        );
                        gradient.addColorStop(0, `rgba(102, 126, 234, ${activation})`);
                        gradient.addColorStop(0.5, `rgba(240, 147, 251, ${activation * 0.5})`);
                        gradient.addColorStop(1, 'rgba(168, 237, 234, 0)');
                        
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(neuron.x, neuron.y, radius * 2, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Core
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9 + activation * 0.1})`;
                        this.ctx.beginPath();
                        this.ctx.arc(neuron.x, neuron.y, radius, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Border
                        this.ctx.strokeStyle = `rgba(102, 126, 234, ${0.5 + activation * 0.5})`;
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    }
                }
            }

            animate() {
                // Subtle neuron movement
                for (let layer of this.neurons) {
                    for (let neuron of layer) {
                        neuron.velocity.y += (Math.random() - 0.5) * 0.2;
                        neuron.velocity.x += (Math.random() - 0.5) * 0.1;
                        neuron.velocity.y *= 0.95;
                        neuron.velocity.x *= 0.95;
                        
                        neuron.y += neuron.velocity.y;
                        neuron.x += neuron.velocity.x;
                        
                        // Constrain to original position
                        const originalY = neuron.y;
                        const originalX = neuron.x;
                        neuron.y += (originalY - neuron.y) * 0.1;
                        neuron.x += (originalX - neuron.x) * 0.1;
                    }
                }
                
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        // Particle System
        class ParticleSystem {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.particles = [];
                this.attractors = [];
                this.gravity = 0.5;
                this.turbulence = 0.3;
                this.particleCount = 500;
                
                this.initialize();
            }

            initialize() {
                this.particles = [];
                for (let i = 0; i < this.particleCount; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        radius: Math.random() * 3 + 1,
                        hue: Math.random() * 60 + 240, // Purple to pink range
                        life: 1
                    });
                }
                
                // Add central attractor
                this.attractors = [{
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    strength: 100
                }];
            }

            update() {
                for (let particle of this.particles) {
                    // Apply gravity to attractors
                    for (let attractor of this.attractors) {
                        const dx = attractor.x - particle.x;
                        const dy = attractor.y - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 10) {
                            const force = (attractor.strength * this.gravity) / (distance * distance);
                            particle.vx += (dx / distance) * force;
                            particle.vy += (dy / distance) * force;
                        }
                    }
                    
                    // Apply turbulence
                    particle.vx += (Math.random() - 0.5) * this.turbulence;
                    particle.vy += (Math.random() - 0.5) * this.turbulence;
                    
                    // Damping
                    particle.vx *= 0.99;
                    particle.vy *= 0.99;
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Wrap around edges
                    if (particle.x < 0) particle.x = this.canvas.width;
                    if (particle.x > this.canvas.width) particle.x = 0;
                    if (particle.y < 0) particle.y = this.canvas.height;
                    if (particle.y > this.canvas.height) particle.y = 0;
                    
                    // Life decay and regeneration
                    particle.life -= 0.002;
                    if (particle.life <= 0) {
                        particle.life = 1;
                        particle.x = Math.random() * this.canvas.width;
                        particle.y = Math.random() * this.canvas.height;
                    }
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw particle trails
                this.ctx.globalCompositeOperation = 'screen';
                
                for (let i = 0; i < this.particles.length; i++) {
                    const particle = this.particles[i];
                    
                    // Connect nearby particles
                    for (let j = i + 1; j < this.particles.length; j++) {
                        const other = this.particles[j];
                        const dx = other.x - particle.x;
                        const dy = other.y - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 100) {
                            const opacity = (1 - distance / 100) * 0.3 * particle.life;
                            this.ctx.strokeStyle = `hsla(${particle.hue}, 70%, 70%, ${opacity})`;
                            this.ctx.lineWidth = 0.5;
                            this.ctx.beginPath();
                            this.ctx.moveTo(particle.x, particle.y);
                            this.ctx.lineTo(other.x, other.y);
                            this.ctx.stroke();
                        }
                    }
                    
                    // Draw particle
                    const gradient = this.ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, particle.radius * 3
                    );
                    gradient.addColorStop(0, `hsla(${particle.hue}, 70%, 70%, ${particle.life})`);
                    gradient.addColorStop(1, `hsla(${particle.hue}, 70%, 70%, 0)`);
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.radius * 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.globalCompositeOperation = 'source-over';
            }

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        // Audio Synthesis Engine
        class AudioEngine {
            constructor() {
                this.audioContext = null;
                this.oscillators = [];
                this.gainNodes = [];
                this.playing = false;
                this.baseFrequency = 440;
                this.harmonics = 3;
            }

            initialize() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

            playNeuralMusic(neuralData) {
                if (this.playing) this.stop();
                
                this.initialize();
                this.playing = true;
                
                const frequencies = this.generateFrequencies(neuralData);
                
                for (let i = 0; i < this.harmonics; i++) {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.frequency.value = frequencies[i % frequencies.length];
                    oscillator.type = ['sine', 'triangle', 'square'][i % 3];
                    
                    gainNode.gain.value = 0;
                    gainNode.gain.linearRampToValueAtTime(0.1 / (i + 1), this.audioContext.currentTime + 0.1);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start();
                    
                    this.oscillators.push(oscillator);
                    this.gainNodes.push(gainNode);
                }
                
                // Modulate based on neural activity
                this.modulateSound();
            }

            generateFrequencies(neuralData) {
                const pentatonic = [1, 1.125, 1.25, 1.5, 1.667]; // Pentatonic ratios
                return pentatonic.map(ratio => this.baseFrequency * ratio);
            }

            modulateSound() {
                if (!this.playing) return;
                
                for (let i = 0; i < this.oscillators.length; i++) {
                    const modulation = Math.sin(Date.now() * 0.001 * (i + 1)) * 0.05 + 0.05;
                    this.gainNodes[i].gain.linearRampToValueAtTime(
                        modulation,
                        this.audioContext.currentTime + 0.1
                    );
                }
                
                requestAnimationFrame(() => this.modulateSound());
            }

            generateMelody() {
                if (this.playing) this.stop();
                
                this.initialize();
                const notes = [261.63, 293.66, 329.63, 392.00, 440.00, 493.88, 523.25];
                const duration = 200;
                
                let time = 0;
                for (let i = 0; i < 16; i++) {
                    const note = notes[Math.floor(Math.random() * notes.length)];
                    setTimeout(() => this.playNote(note, duration), time);
                    time += duration;
                }
            }

            playNote(frequency, duration) {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration / 1000);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration / 1000);
            }

            stop() {
                this.playing = false;
                for (let oscillator of this.oscillators) {
                    oscillator.stop();
                }
                this.oscillators = [];
                this.gainNodes = [];
            }
        }

        // Visualization Charts
        class DataVisualizer {
            constructor() {
                this.lossHistory = [];
                this.activationPatterns = [];
                this.spectrumData = [];
                this.phaseData = [];
                this.time = 0;
            }

            drawLossLandscape(canvas) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                // Generate loss landscape
                const resolution = 50;
                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        const x = (i / resolution) * width;
                        const y = (j / resolution) * height;
                        
                        // Simulated loss function
                        const loss = Math.sin(i * 0.2) * Math.cos(j * 0.2) + 
                                   Math.sin(i * 0.1 + this.time) * 0.5;
                        
                        const hue = 240 + loss * 60;
                        const lightness = 50 + loss * 30;
                        
                        ctx.fillStyle = `hsl(${hue}, 70%, ${lightness}%)`;
                        ctx.fillRect(x, y, width / resolution + 1, height / resolution + 1);
                    }
                }
                
                // Draw gradient descent path
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let t = 0; t < 100; t++) {
                    const x = (Math.sin(t * 0.1 + this.time) + 1) * width / 2;
                    const y = (Math.cos(t * 0.15 + this.time) + 1) * height / 2;
                    
                    if (t === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            drawActivationPatterns(canvas) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                // Draw activation heatmap
                const cols = 20;
                const rows = 10;
                const cellWidth = width / cols;
                const cellHeight = height / rows;
                
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        const activation = Math.sin(i * 0.5 + this.time) * 
                                         Math.cos(j * 0.5 + this.time * 0.7) * 0.5 + 0.5;
                        
                        const gradient = ctx.createRadialGradient(
                            i * cellWidth + cellWidth / 2,
                            j * cellHeight + cellHeight / 2,
                            0,
                            i * cellWidth + cellWidth / 2,
                            j * cellHeight + cellHeight / 2,
                            cellWidth
                        );
                        
                        gradient.addColorStop(0, `hsla(${280 - activation * 40}, 70%, ${50 + activation * 30}%, ${activation})`);
                        gradient.addColorStop(1, 'rgba(168, 237, 234, 0.1)');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(i * cellWidth, j * cellHeight, cellWidth, cellHeight);
                    }
                }
            }

            drawSpectrum(canvas) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                // Draw frequency bars
                const bars = 32;
                const barWidth = width / bars;
                
                for (let i = 0; i < bars; i++) {
                    const freq = Math.sin(i * 0.3 + this.time * 2) * 0.5 + 0.5;
                    const barHeight = freq * height * 0.8;
                    
                    const gradient = ctx.createLinearGradient(
                        i * barWidth, height,
                        i * barWidth, height - barHeight
                    );
                    gradient.addColorStop(0, 'rgba(168, 237, 234, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(240, 147, 251, 0.8)');
                    gradient.addColorStop(1, 'rgba(102, 126, 234, 0.8)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(
                        i * barWidth + 2,
                        height - barHeight,
                        barWidth - 4,
                        barHeight
                    );
                }
            }

            drawPhaseSpace(canvas) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                // Lorenz attractor
                const scale = 3;
                const centerX = width / 2;
                const centerY = height / 2;
                
                ctx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                
                let x = 0.1, y = 0, z = 0;
                const sigma = 10, rho = 28, beta = 8/3;
                const dt = 0.01;
                
                for (let i = 0; i < 2000; i++) {
                    const dx = sigma * (y - x) * dt;
                    const dy = (x * (rho - z) - y) * dt;
                    const dz = (x * y - beta * z) * dt;
                    
                    x += dx;
                    y += dy;
                    z += dz;
                    
                    const screenX = centerX + x * scale;
                    const screenY = centerY + y * scale;
                    
                    if (i === 0) ctx.moveTo(screenX, screenY);
                    else ctx.lineTo(screenX, screenY);
                    
                    // Color variation
                    if (i % 100 === 0) {
                        ctx.stroke();
                        const hue = 240 + (i / 2000) * 60;
                        ctx.strokeStyle = `hsla(${hue}, 70%, 60%, ${0.3 + i / 4000})`;
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY);
                    }
                }
                ctx.stroke();
            }

            animate() {
                this.time += 0.02;
                
                this.drawLossLandscape(document.getElementById('lossChart'));
                this.drawActivationPatterns(document.getElementById('activationChart'));
                this.drawSpectrum(document.getElementById('spectrumChart'));
                this.drawPhaseSpace(document.getElementById('phaseChart'));
                
                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize everything
        window.addEventListener('DOMContentLoaded', () => {
            // Setup canvases
            const neuralCanvas = document.getElementById('neuralCanvas');
            const particleCanvas = document.getElementById('particleCanvas');
            
            function resizeCanvases() {
                const container = document.querySelector('.canvas-container');
                neuralCanvas.width = container.offsetWidth;
                neuralCanvas.height = container.offsetHeight;
                particleCanvas.width = container.offsetWidth;
                particleCanvas.height = container.offsetHeight;
            }
            
            resizeCanvases();
            window.addEventListener('resize', resizeCanvases);
            
            // Initialize systems
            const neuralNet = new NeuralNetwork(neuralCanvas);
            const particles = new ParticleSystem(particleCanvas);
            const audio = new AudioEngine();
            const visualizer = new DataVisualizer();
            
            // Setup chart canvases
            const charts = ['lossChart', 'activationChart', 'spectrumChart', 'phaseChart'];
            charts.forEach(id => {
                const canvas = document.getElementById(id);
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            });
            
            // Start animations
            neuralNet.animate();
            particles.animate();
            visualizer.animate();
            
            // Neural Network Controls
            document.getElementById('learningRate').addEventListener('input', (e) => {
                neuralNet.learningRate = parseFloat(e.target.value);
                document.getElementById('learningRateValue').textContent = e.target.value;
            });
            
            document.getElementById('complexity').addEventListener('input', (e) => {
                const complexity = parseInt(e.target.value);
                document.getElementById('complexityValue').textContent = complexity;
                neuralNet.layers = [4, complexity * 2, complexity * 2, 3];
                neuralNet.initializeNetwork();
            });
            
            document.getElementById('trainBtn').addEventListener('click', () => {
                neuralNet.training = !neuralNet.training;
                if (neuralNet.training) {
                    neuralNet.train();
                    document.getElementById('trainBtn').textContent = 'Stop Training';
                } else {
                    document.getElementById('trainBtn').textContent = 'Train Network';
                }
            });
            
            document.getElementById('resetBtn').addEventListener('click', () => {
                neuralNet.training = false;
                neuralNet.epochs = 0;
                neuralNet.accuracy = 0;
                neuralNet.initializeNetwork();
                document.getElementById('trainBtn').textContent = 'Train Network';
                document.getElementById('accuracy').textContent = '0%';
                document.getElementById('epochs').textContent = '0';
            });
            
            // Particle Controls
            document.getElementById('particleCount').addEventListener('input', (e) => {
                particles.particleCount = parseInt(e.target.value);
                document.getElementById('particleCountValue').textContent = e.target.value;
            });
            
            document.getElementById('gravity').addEventListener('input', (e) => {
                particles.gravity = parseFloat(e.target.value);
                document.getElementById('gravityValue').textContent = e.target.value;
            });
            
            document.getElementById('turbulence').addEventListener('input', (e) => {
                particles.turbulence = parseFloat(e.target.value);
                document.getElementById('turbulenceValue').textContent = e.target.value;
            });
            
            document.getElementById('particleBtn').addEventListener('click', () => {
                particles.initialize();
            });
            
            document.getElementById('attractorBtn').addEventListener('click', () => {
                particles.attractors.push({
                    x: Math.random() * particleCanvas.width,
                    y: Math.random() * particleCanvas.height,
                    strength: 50 + Math.random() * 100
                });
            });
            
            // Audio Controls
            document.getElementById('frequency').addEventListener('input', (e) => {
                audio.baseFrequency = parseInt(e.target.value);
                document.getElementById('frequencyValue').textContent = e.target.value;
            });
            
            document.getElementById('harmonics').addEventListener('input', (e) => {
                audio.harmonics = parseInt(e.target.value);
                document.getElementById('harmonicsValue').textContent = e.target.value;
            });
            
            document.getElementById('playBtn').addEventListener('click', () => {
                const neuralData = neuralNet.neurons.map(layer => 
                    layer.map(n => n.activation)
                ).flat();
                audio.playNeuralMusic(neuralData);
            });
            
            document.getElementById('stopBtn').addEventListener('click', () => {
                audio.stop();
            });
            
            document.getElementById('generateBtn').addEventListener('click', () => {
                audio.generateMelody();
            });
        });
    </script>
</body>
</html>